*nvim-note*

# keymap

| keymap                          | 功能                                                     |
|---------------------------------|----------------------------------------------------------|
| `<s-f1>`                        | 文件树                                                   |
| `<f2>` ,`<s-f2>`                | 下一处上一处诊断                                         |
| `<s-f3>`                        | terminal                                                 |
| `<a-f3>`                        | next terminal                                            |
| `<s-f4>`                        | Neogit                                                   |
| `<s-f5>`                        | lsp_dynamic_workspace_symbols                            |
| `<c-f5>`                        | lsp_document_symbols                                     |
| `<s-f6>`                        | refactor rename                                          |
| `<c-f7>`                        | toggle_breakpoint                                        |
| `<s-f7>`                        | clear_breakpoint                                         |
| `<c-f8>`                        | load session                                             |
| `<c-f9>`                        | history file                                             |
| `<c-f10>`                       | search in cdlist                                         |
| `<c-f11>`                       | search in session dir                                    |
| `<c-f12>`                       | buffers list                                             |
| `<c-space>`                     | buffers list of cwd                                      |
| `<a-enter>`,`<d-enter>`         | code action                                              |
| `<a-h>`,`<d-h>`                 | hover help                                               |
| `<leader>le`                    | 在float 窗口显示详细诊断信息                             |
| `<leader>lq`                    | 诊断问题发送到 loclist                                   |
| `<leader>lf`                    | lsp 格式化                                               |
| `<leader>gd`                    | goto definition                                          |
| `<leader>gr`                    | goto references                                          |
| `<leader>gD`                    | goto declaration                                         |
| `<leader>gt`                    | goto type_definition                                     |
| `<leader>gi`                    | 跳转到类型实现的接口                                     |
| `<leader>gu`                    | 打开链接                                                 |
| `<leader>wa`                    | lsp add_workspace_folder                                 |
| `<leader>wr`                    | lsp remove_workspace_folder                              |
| `<leader>wl`                    | lsp list_workspace_folder                                |
| `<c-tab>`, `<a-tab>`, `<s-tab>` | buffer cycle                                             |
| `<leader>hn`                    | hunk next                                                |
| `<leader>hp`                    | hunk prev                                                |
| `<leader>hv`                    | hunk preview                                             |
| `<leader>S`                     | normal模式 打开搜索窗口, cwd全局搜索                     |
| `<leader>sw`                    | normal模式 搜索光标所在的词,cwd全局搜索                  |
| `<leader>sp`                    | normal模式 (search in path)打开搜索窗口, 仅搜索当前文件. |
| `<leader>s`                     | visual模式 搜索光标选择的词,cwd全局搜索                  |
| `ga.`                           | open text case telescope                                 |
| `<leader>df`                    | DiffviewOpen                                             |
| `<leader>dh`                    | DiffviewFileHistory                                      |
| `<leader>dc`                    | :tabc                                                    |
| `<leader>fw`                    | :newtab %                                                |


# 部署

0. 安裝字体 `https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/UbuntuMono.zip`
1. 将nvim 复制到 `~/config/nvim`
2. 安装packer插件管理器 `git clone --depth 1 https://github.com/wbthomason/packer.nvim   ~/.local/share/nvim/site/pack/packer/start/packer.nvim`
3. 启动nvim, 执行`:PackerInstall`,`:PackerCompile`
4. Lanuch Neovide, install treesitter dependence
5. Install Lua Runtime , Install `https://github.com/sumneko/lua-language-server/releases`
6. 安装 `cargo install tree-sitter-cli`, 需要先安装rust
7. 編輯 `~/.config/nvim/lua/configs/treesitter.lua`
8. 編輯 `~/.config/nvim/lua/configs/lspconfig.lua`, 刪掉不需要的語言配置
9. 安裝需要的 lsp server
10. 安装 `https://github.com/BurntSushi/ripgrep#installation`
11. `:checkhealth`

## mac快捷键

mac的option对应其他系统的alt键，但是默认键盘布局，option+字母或者数字是用来输入特殊字符的，无法修改。

解决方法: 修改系统设置，键盘-输入法。删掉"英文"，添加 "Unicode 16进制输入法"; 修改中文输入法的编好设置，在“按键”-“键盘布局”里选择“Unicode 16进制输入法”, 这样就可以自己定义 alt快捷键了

## 常用 lsp server

```
:Mason
```

Mason 会将lsp server安装在 `~/.local/share/nvim/mason/bin/` 并在启动时注入 PATH 环境变量.

如果系统已经安装有相应的lsp server, 就不必充分安装了.

rust:

```sh
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# linux
curl -L https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - > ~/bin/rust-analyzer
chmod +x ~/in/rust-analyzer
# mac
brew install rust-analyzer
```

java

```
https://github.com/georgewfraser/java-language-server
```

# FAQ

* 插件不用,必须用 `:PackerClean` 卸载干净

* 自定义 vim标题栏内容: `set title`, 默认会显示文件名和目录, 可以通过`set titlestring="自己的标题"` 进行修改,示例:
```
:auto BufEnter * let &titlestring = hostname() .. "/" .. expand("%:p")
:set title titlestring=%<%F%=%l/%L-%P titlelen=70
```
* 可以使用项目仓库名,session名作为title

VIM 
========================

1. `:h keycodes` 查看键盘按键代码
1. `:h builtin` 查看vim内置 fn
2.  光标跳转: `<c-o>`上一jump位置, `<c-i>`下一jump位置


`set linespace` 行距设置, 解决部分gui行距不合适的问题

## join

`J` 合并会在两行直接添加一个空格, 有时候不需要空格, 可以使用`gJ`代替.

normal模式: 按下`gJ` 会将当前行和下一行合并为一行, 合并不会添加任何空格.
visual模式: 按下`gJ` 多行合并为一行, 合并不会添加任何空格.


## 粘贴

当vim开启smartindent时，对于代码会有自动换行的功效。但是，有时候我们需要在向vim中粘贴代码时，需要暂时关闭自动换行的功能。

解决方法：
:set paste
之后进行插入操作，vim提示变为： – INSERT (paste) –
这时就不再有自动换行。

恢复：
:set nopaste
vim提示变为：– INSERT –

## 宏

录制和执行宏:

1. `q{register}` 开始录制宏, `{register}` 为寄存器名
    * register 一般用是 a-z, 0-9
    * 开始录制后，会显示 `recording @{register}` , 表示正在录制宏
2. 再次按下`q` 结束录制宏
3. `@{register}` 执行宏, `{register}` 为寄存器名
5. `{count}@{register}` 重复执行宏若干次
4. `@@` 重复执行上一次宏,`10@@` 重复执行上一次宏10次
6. `:reg {register}` 查看指定寄存器内容, 宏的寄存器type为 c, content为录制的按键

修改宏:

1. 录制过程可以临时终止录制，然后使用A-Z作为寄存器继续录制宏。例如使用A录制宏，其实就是在a寄存器内的宏后面追加新的内容

2. 使用 `:put {register}` 将寄存器内容放到编辑区域, 编辑内容后，再使用 `:d {register}` 将编辑后的内容放回寄存器

删除宏： 例如: `:let @a=''`

## terminal

进入 terminal 模式后，可以使用 `<c-\><c-n>`退出terminal模式回到normal模式.

terminal 模式不能访问寄存器，需要粘贴内容的时候，可以回到 normal模式，
执行粘贴操作将内容粘贴到命令行输入区域，然后再重新进入terminal模式.


## 换行符处理

1. 将粘贴的文本中的windows换行符`\r\n`处理为unix换行符`\n`, 只需要执行搜索删除掉`\r`即可: `:s/\n//g`

2. vim在执行write命令时，会根据buffer的 `fileformat` 自动处理换行符.

3. 修改整个文件的换行符模式，只需要设置buffer的 `fileformat` 选项即可

4. vim在打开文件时可以根据`fileformats` 选项选择最合适的换行符, 默认值为 'unix,dos', 无需特别设置.

5. 向一个文件中一次粘贴很大的文本时，如果换行符与文件的换行符不一致，会产生卡顿卡死的问题(触发了某些插件的执行), 所以粘贴前可以先转换好换行符再粘贴.
或者new一个空白文件，粘贴进去处理好，再往文件里粘贴.

## 输入特殊字符

输入模式下，使用`<c-v>`激活特殊输入
* 这时按回车，就完成了`^M` 换行符(根据fileformat字段使用`\r\n`或`\n`)的输入, 主要用于在单行输入模式(例如cmdline模式)里，录入换行文本。
* 在cmdline模式，按下tab就完成了`^I`换行符的输入.
* 按需任意组合键或功能键，就完成了组合键功能键的输入.

## 内置函数

| function              | 返回                   | 功能                                                                     |
| ----                  | ----                   | ----                                                                     |
| has(feature)          | 存在返回1，不存在返回0 | 判断是否存在某个特性, 例如: "win64","mac","linux","nvim","python3","wsl" |
| exists({expr})        | number                 | 用于判断option,variable,function,colorscheme,command 是否存在            |
| has_key({dict},{key}) | 存在返回1，不存在返回0 | 判断 dict里是否存在key                                                   |
| line({expr})          | number                 | 返回行号. 可以根据光标位置，最后一行, mark, 等方式返回行号               |
| expand({string})      | string                 | 扩展文件相关的字符串                                                     |
| filereadable({file})  | bool                   | 文件存在且可读，返回true; 否则返回false                                  |

## registers 寄存器

vim 提供了一些寄存器，可以通过yank操作讲选择的内容放入寄存器或从寄存器取出:


1. The unnamed register `""`
    * 自动存放了上一次删除命令(d,c,s,x)内容的存储
2. 10 numbered registers `"0` to `"9`
    * 自动按次序存放了历史删除命令(d,c,s,x)内容的存储
    * 数值越大，历史越久.
    * 也可以手动存放覆盖掉里面的内容,但没有必要.
3. The small delete register `"-`
    * 自动存放了小于一行文本的被删除内容.
4. 26 named registers `"a` to `"z` or `"A` to `"Z`
    * 用于手动存放自己的内容，小写是replace,大写是append
5. 只读寄存器 `":`, `".`, `"%`
    * `".` 存储最后一次insert的内容(insert mode执行ctrl-a就是插入的此寄存器内容)
    * `"%` 存储了当前文件名
    * `":` 存储了最后一次执行的命令
6. Alternate buffer register `"#`
    * 存放了当前文件的alternate file的文件名
7. The expression register `"=`
    * 并不是一个真正的寄存器 "="
8. The selection registers `"*` and `"+`
    * 供GUI环境使用，用于打通系统剪贴板，如果gui环境这两个寄存器不可用，则会使用`""`寄存器.
9. The black hole register `"_`
    * 如果删除时，不希望影响到任何其他寄存器，可以用这个寄存器
10. Last search pattern register `"/`
    * 存放了最后一次搜索的内容.

你可以通过command`let @` 向寄存器里写内容,例如向 `"a` 寄存器里写入 "hello":

```
:let @a='hello'
```

如果不指定寄存器，则向近一次

使用 `:dis[play]` 可以列出所有寄存器及内容

可以利用寄存器将保持命令执行的输出,例如:

```
:let @a=execute('!git status')
```

## map Mode 


| Mode Command | Normal | Insert | Cmdline | Visual | Select | Oprator-pending | Terminal | Lang-Arg |
| -------      | ------ | -----  | -----   | -----  | -----  | -----           | ------   | ------   |
| [nore]map    | yes    | -      | -       | yes    | yes    | yes             | -        | -        |
| n[nore]map   | yes    | -      | -       | -      | -      | -               | -        | -        |
| [nore]map!   | -      | yes    | yes     | -      | -      | -               | -        | -        |
| i[nore]map   | -      | yes    | -       | -      | -      | -               | -        | -        |
| c[nore]map   | -      | -      | yes     | -      | -      | -               | -        | -        |
| v[nore]map   | -      | -      | -       | yes    | yes    | -               | -        | -        |
| x[nore]map   | -      | -      | -       | yes    | -      | -               | -        | -        |
| s[nore]map   | -      | -      | -       | -      | yes    | -               | -        | -        |
| o[nore]map   | -      | -      | -       | -      | -      | yes             | -        | -        |
| t[nore]map   | -      | -      | -       | -      | -      | -               | yes      | -        |
| l[nore]map   | -      | yes    | yes     | -      | -      | -               | -        | yes      |

## cmdline

### 复制粘贴

先按下 Ctrl-r ，然后选择从哪个寄存器上粘贴

* `"` 从yank寄存器
* `+` 从+寄存器
* `*` 从*寄存器

### 可expand的特殊参数

可以直接作为cmdline里命令的参数使用, 自动被expand. 也可以在脚本中使用 expand()函数手动扩展

1. `%` 当前文件相对于当前 working directory 为`~/test/`, 文件路径为`~/test/project/readme.md`, 则`%`的值为: `project/readme.md`
- 试试 `:!echo %`
2. `<cword>` 光标所在处的word
- 试试 `:!echo <cword>`
3. `<cWORD>` 光标所在处的WORD
- 试试 `:!echo <cWORD>`

#### 文件名修饰符

特殊参数`%`后面可以使用修饰符:

* :p	必须是第一个修饰符,转为绝对路径.  例如:`:!echo %:p`	
* :~	如果是home目录下的文件,转为 `~/`格式 的路径 
* :.	相对于当前工作目录的相对路径.
* :h	(head)去掉文件名(最后一个/及后面的字符),只保留路径,如果文件末尾是`/`,则移除的是`/`
    - 试试 `:cd %:h`
* :t	(tail)去除路径,只保留文件名  Must precede any :r or :e.
* :r	去除最后一个后缀 (the last extension removed).	如果文件是.开头没有其他后缀,不会移除
* :e	保留文件的后缀(不含.号).如果文件没有后缀,或者只有一个.开头,结果是空.
* :s?pat?sub?  使用正则替换修改文件路径,只替换第一次的匹配
* :gs?pat?sub? 使用正则替换修改文件路径,替换每一次的匹配


## 常用 motion 键

| H          | 移动光标到屏幕顶部行首                                      |
| M          | 移动光标到屏幕中部行首                                      |
| L          | 移动光标到屏幕底部行首                                      |
| w          | 移动光标到下一单词的开头                                    |
| W          | 移动光标到下一连续字符的开头                                |
| b          | 移动光标到单词开头,如果已经在单词开头，移动到上一单词的开头 |
| B          | 移动光标到一组连续字符(或上一连续字符)开头                  |
| e          | 移动光标到单词末尾,如果已经在单词末尾，移动到下一单词的末尾 |
| E          | 移动光标到一组连续字符(或上一连续字符)末尾                  |
| ge         | 移动光标到上一个单词的结尾                                  |
| gg         | 移动光标到文件首                                            |
| G          | 移动光标到文件末尾                                          |
| -          | 移动光标到上一行行首(非空白字符)                            |
| +或Enter   | 移动光标到下一行行首(非空白字符)                            |
| {n}<space> | 光标向后移动n个字符                                         |
| {n}<Enter> | 光标向下移动n行到行首(非空白字符)                           |
| {n}G       | 移动到第n行行首(非空白字符)                                 |
| ]m         | 移动到下一个代码块的开头                                    |
| [m         | 移动到上一个代码块的开头                                    |
| ]M         | 移动到下一个代码块的末尾                                    |
| [M         | 移动到上一个代码块的末尾                                    |


## vim 内置 text objecg

| 操作              | 作用                        |
| --------          | --------------------------- |
| aw                | 单词,含单词后的空格         |
| iw                | 单词,不含单词后的空格       |
| as                | 一句,含句号后的空格         |
| ap                | 段落,含段落尾部的空行       |
| ip                | 段落,不含段落尾部的空行     |
| a'                | 单引号之间的内容,含单引号   |
| a"                | 双引号之间的内容,含双引号   |
| i'                | 单引号之间的内容,不含单引号 |
| i"                | 双引号之间的内容,不含双引号 |
| a),a(,a},a{,a],a[ | 各种括号之间的文本对象      |
| i),i(,i},i{,i],i[ | 各种括号之间的文本对象      |
| aB,ab,ib,iB,      | B,b指圆括号                 |

## window 导航


| @            | @                                                 |
| ------------ | -------------------------------------             |
| [Ctrl] + [f] | forward下翻一页相当于 [Page Down]按键             |
| [Ctrl] + [b] | backword上翻一页[Page Up] 按键                    |
| [Ctrl] + [d] | down屏幕『向下』移动半页                          |
| [Ctrl] + [u] | up屏幕『向上』移动半页                            |
| Ctrl + E     | 窗口向上滚动                                      |
| Ctrl + Y     | 窗口向下滚动                                      |
| zz           | 滚动窗口使光标所在行处于屏幕正中                  |
| zt           | 滚动窗口使光标所在行处于屏幕最上                  |
| zb           | 滚动窗口使光标所在行处于屏幕最下                  |
| ctrl+w       | 窗口切换(需配合定位命令)                          |


| ctrl-w s      | 水平分隔窗口打开一份文件副本                  |
| ctrl-w v      | 垂直分隔窗口打开一份文件副本                  |
| ctrl-w n      | 水平分隔窗口打开一个空buffer                  |
| ctrl-w o      | 在屏幕中只保留当前窗口 , 所有的其他窗口都关闭 |
| :new [file]   | 水平分隔窗口打开一个空buffer                  |
| :vnew [file]  | 垂直分隔窗口打开一个空buffer                  |
| ctrl-w c      | 多窗口时，关闭当前窗口                        |
| ctrl-w q      | 退出vim                                       |
| ctrl-w ctrl-w | 在窗口之间切换，从上向下，从左向右            |

### 垂直窗口中打开命令产生的窗口

help 窗口默认是水平分割出的，使用下面的命令，可以在垂直分割出的窗口中打开:

```
:vert h
```

### window-moving

```
:help window-moving 
```


窗口 rotate, rotate 的窗口必须是完全相邻的窗口边界,优先上下rotate:

|<c-w>+r   | 交换窗口, 所有窗口之间轮换, 上面的向下移动(或者左边的向右边移动) | 
|<c-w>+R   | 交换窗口, 所有窗口之间轮换, 下面的向上移动(或者右边的向左边移动) | 
|<c-w>+x   | 交换窗口, 仅与下方相邻(或右侧相邻)的窗口之间交换 | 



窗口 moving:

|<c-w>+K   | 将当前窗口,移动到 **所有** 其他窗口的顶部| 
|<c-w>+J   | 将当前窗口,移动到 **所有** 其他窗口的下面| 
|<c-w>+H   | 将当前窗口,移动到 **所有** 其他窗口的左侧| 
|<c-w>+L   | 将当前窗口,移动到 **所有** 其他窗口的右侧| 

### window-resizing

|<c-w> =  | 上下均分,左右均分 | 


### 代码折叠


删除折叠: 被删除后的折叠，无法再折叠起来。

展开折叠: 被展开的折叠，可以再次折叠起来。

| 操作               | 功能                                           |
|--------------------|------------------------------------------------|
| zi                 | 开启/关闭代码折叠, 但不会改变文本的折叠的状态. |
| zf{motion commond} | 创建折叠,例如: zf5n 向下折叠5行文本            |
| {Visual}zf         | 折叠Visual模式选择的文本                       |
| zd                 | 删除光标处折叠,但不会删除内嵌的折叠            |
| zD                 | 删除光标处的所有折叠                           |
| zE                 | 删除窗口里的所有折叠                           |
| zo{n}              | 展开光标处的折叠                               |
| zO                 | 展开光标处的折叠,包括内嵌的折叠                |
| zc{n}              | 收起光标处的折叠                               |
| zC                 | 收起光标处的折叠,包括内嵌的折叠                |
| za{n}              | 展开/收起光标处折叠                            |
| zA                 | 展开/收起光标处的所有折叠                      |


### 在折叠中移动光标

折叠被创建后，无论收起还是展开，以下操作都是有效的

| 操作 | 功能                                                                     |
|------|--------------------------------------------------------------------------|
| [z   | 移动到折叠区块的第一行, 如果已经在第一行，则移动到上一层折叠的第一行     |
| ]z   | 移动到折叠区块的最后行, 如果已经在最后一行，则移动到上一层折叠的最后一行 |
| zj   | 向下移动到下一个折叠的头部，一个收起的折叠被视为一个折叠                 |
| zk   | 向上移动到下一个折叠的头部，一个收起的折叠被视为一个折叠                 |

### zr,zM,zr,zR

vim的代码折叠, 是按层级折叠的. 所有代码块都有一个代表自己层级的值. 

例如, 代码共有5层, 第一次zm会折叠所有第五层的代码块, 再一次zm折叠所有第四层的代码块.

| 操作 | 功能             |
|------|------------------|
| zm   | 继续收拢更多折叠 |
| zM   | 收拢所有折叠     |
| zr   | 展开更多折叠     |
| zR   | 展开所有折叠     |

## quickfix


| cmd             | 功能             |
|-----------------|------------------|
| :h quickfix     | 显示quickfix帮助 |
| :copen [height] | 显示quickfix窗口 |


## remote 编辑

nvim 可以通过参数以 client或server的模式启动

| cmd               | 功能                                           |
|-------------------|------------------------------------------------|
| `--server {addr}` | 连接到nvim server                              |
| `--listen {addr}` | 启动一个nvim server                            |
| `--headless`      | 配合listen使用，单纯启动server，不启动用户界面 |


## libuv

```
local uv = vim.loop
```

提供: 事件循环，timmer, dns工具函数, 异步执行函数, 进程和系统相关的杂项工具函数。以及各种handler封装: poll, signal, process, stream, tcp, udp, pipe, tty, fs, threadpool

常用函数:

* uv.now() 
* uv.sleep({msec})
* uv.cwd()
* uv.chdir({cwd})
* uv.random({len}, {flags} [, {callback}])

## neovim-qt

要支持远程client nvim-qt与client os之间的系统剪贴板，需要在client-qt上执行 `:call GuiClipboard()`, 然后就可以在client-qt 上使用 "+p, "+y 访问系统剪贴板了.


NvimTree 高频快捷键
========================

- `g?`  [go help]  显示/关闭Nvim keymap 帮助

## Tree 操作与导航

- `q` [quit]关闭文件树
- `W` [Wrap] 全部折叠
- `E` [Expand] 展开光标目录的全部子目录
- `H`  [Hidden toggle] 切换 . 文件显示
- `I` 切换显示/隐藏 .gitignore 隐藏的文件
- `R` [Refresh] 刷新Tree
- `P` 光标移动到上级目录
- `<c-]` Tree Root切换到该目录
- `-` Tree Root 切到上一级目录
- `s` [system]  打开系统默认文件管理器
- `f` [filter] 过滤tree中的文件,只显示与filter匹配的文件. 
- 配合 `E` 可以快速搜索Tree下的文件. 
- `F` 清除filter

## 文件信息

- `y`    复制文件名到剪贴板
- `Y`    复制相对路径到剪贴板
- `gy`   复制绝对路径到剪贴板
-  `<C-k>` 查看文件信息(路径/大小/修改时间)

## 文件管理

- `r` [rename] 重命名
- `a` [add] 添加文件或目录
- `c` [copy] 复制
- `x` [cut] 剪切文件
- `p` [paste] 粘贴
- `d` [remove] 删除
- `D` [Trash] 放到回收站
- `.` 进入cmdline模式 , 并将文件路径自动填充在光标后面, 以输入命令,并使用文件路径作为参数执行.

## 编辑文件

- `o`,`<cr>` 有多个窗口,选择在哪个窗口编辑文件. 单个窗口, 在新tab打开
- `O` 有多个窗口, 直接在当前窗口编辑文件. 单个窗口, 在新tab打开
- `<c-x>` split. 分隔出新水平窗口打开文件
- `<c-v>` vsplit. 分隔出新垂直窗口打开文件
- `<c-t>` tabnew. 在新tab打开
- `<tab` 预览文件

## 命令与映射

* `:NvimTreeToggle` : 展开隐藏NvimTree, 会保持Tree状态不变.

* `:NvimTreeFindFileToggle` 定位光标到当前bufname对应的tree文件位置(如果文件位于当前tree的话).

* `:NvimTreeResize width` , `:NvimTreeResize +width`, `:NvimTreeResize -width` 调整tree的宽度

* `gt` normal模式, go to tree. 


close-buffers.nvim
=====

| 命令                         | 作用                                                         |
|------------------------------|--------------------------------------------------------------|
| BDelete hidden               | 关闭所有当前window不可见的buffers                            |
| BDelete other                | 关闭初当前focus的buffer 外的所有buffers                      |
| BDelete all                  | 关闭所有buffers                                              |
| BDelete hidden glob=*.md     | hidden,other,all 支持按glob匹配关闭                          |
| BDelete hidden regex=.*[.]md | hidden,other,all 支持按正则匹配关闭                          |
| BDelete glob=*.md            | 支持按glob/regex匹配关闭                                     |
| BDelete nameless             | 关闭所有无名的buffers                                        |
| BDelete this                 | 关闭当前buffer并且不改变窗口布局(留下的空间会被空buffer替代) |
| BDelete {bufnr}              | 按 :ls 的buffer编号关闭                                      |

bufferline
========================

## tab选择与关闭

1. `:BufferLineCycleNext` and `:BufferLineCyclePrev`
* nomarl 绑定: `<c-tab>`,`<a-tab>`, `<s-tab>`
2. 使用 `:Telescope buffers`, 列出所有tab
	* `<c-space>` 列出cwd的buffers
	* `<s-f12>` 列出所有buffers
3. `:BufferLinePickClose` 选择一个buffer并关闭

## 排序

预设3种排序方式:

* `:BufferLineSortByExtension` 按文件类型排序
* `:BufferLineSortByDirectory` 按文件所属目录排序
* `:BufferLineSortByTabs`

### tab window

* bufferline 的 buffer 位于一个窗口布局下
* bufferline 可以使用tabnew 创建新窗口布局, 实现同一组buffers以不同的窗口布局查看
* 窗口序号在bufferline右侧以数字表示. 使用 `gt` 在窗之间切换


nvim-spectre 搜索替换
========================

* normal模式 `<leader>S` 打开搜索窗口, cwd全局搜索
* visual模式,`<leader>s` 搜索光标选择的词,cwd全局搜索
* normal模式,`<leader>sw` 搜索光标所在的词,cwd全局搜索
* normal模式,`<leader>sp` (search in path)打开搜索窗口, 仅搜索当前文件.
* normal模式,`<leader>q` send_to_quickfix

Trouble 列表
===========

更好用, 不仅可以列出代码诊断问题, 还可以列出定义和引用.

* `:Trouble` 列出所有buffers里的问题代码. 即 `:Trouble workspace_diagnostics`
* `:Trouble lsp_references`: 列出 references 但不会在当前窗口打开,而是临时预览模式. 而 `:Telescope lsp_references` 会打开一个 Telescope 浮窗.
* `:Trouble lsp_definitions`: 列出definitions 但不会在当前窗口打开,而是临时预览模式. 而 `:Telescope lsp_definitions` 会打开新buffer
* `:Trouble lsp_type_definitions`: tupe definitions of the word under the cursor from the builtin LSP client
* `:Trouble document_diagnostics`: document diagnostics from the builtin LSP client
* `:Trouble quickfix`: quickfix items
* `:Trouble loclist`: items from the window's location list

最重要的功能: 配置一下(`<c-t>`映射), 可以把任何Telescope的结果,发送到Troulbe窗口.(见文档)

LSP
======

文档: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/

vim api：`vim.lsp`, `vim.diagnostic`

Telescope
========

| Mappings     | Action                                                        |
| ----         | ----                                                          |
| <C-/>        | 最有用的快捷键.Show mappings for picker actions (insert mode) |
| <C-n>/<Down> | Next item                                                     |
| <C-p>/<Up>   | Previous item                                                 |
| <CR>         | 当前窗口打开                                                  |
| <C-x>        | spli打开                                                      |
| <C-v>        | vsplit 打开                                                   |
| <C-t>        | 新 tab 打开                                                   |
| <C-u>        | 预览窗口向上翻页                                              |
| <C-d>        | 预览窗口向下翻页                                              |
| <C-c>        | Close telescope                                               |
| <Tab>        | Toggle selection and move to next selection                   |
| <S-Tab>      | Toggle selection and move to prev selection                   |
| <C-q>        | 发送所有匹配的选择到 (qflist)                                 |
| j/k          | Next/previous (in normal mode)                                |
| H/M/L        | Select High/Middle/Low (in normal mode)                       |
| gg/G         | Select the first/last item (in normal mode)                   |
| ?            | Show mappings for picker actions (normal mode)                |
| <Esc>        | Close telescope (in normal mode)                              |

有些 Telescope 命令支持需选项, 这种 Telescope 调用示例:

```lua
require("telescope.builtin").find_files({hidden=true, layout_config={prompt_position="top"}})
```

对应的cmd命令方式:


```
:Telescope find_files hidden=true layout_config={"prompt_position":"top"}
```

Picker
--------

根据需要,你可以把任何picker绑定到键.

示例:

```
:nnoremap <Leader>pp :lua require'telescope.builtin'.planets{}
```

下面是一些高频pickers

### File pickers

会忽略.gitignoe里的文件

* `builtin.find_files`	在当前工作目录下查找文件.( 默认会忽略.gitignoea/.ignore里的文件,以及.开头的其他文件)
* 支持的选项
* cwd string 搜索的目录,默认为当前工作目录
* follow bool 是否follow符号链接, 默认false
* hidden bool 是否搜索隐藏文件,默认为false,不搜索隐藏目录和文件.
* no_ignore bool 是否搜索.ignore,.gigignore里的文件,默认为false, 不搜索这两个文件中匹配的内容.
* no_ignore_parent bool 是否搜索父目录.ignore,.gigignore里的文件,默认为false
* search_dirs table 搜索的目录列表,可以是相对cwd的目录,也可以是绝对目录.
* `builtin.live_grep`	在当前工作目录下的文件内容里实时模糊搜索
* 支持的选项
* `builtin.oldfiles` 查找历史编辑文件
* 支持的选项
* `builtin.grep_string`	在当前工作目录下的文件内容里搜索光标处的单词.

### lsp pickers

* `builtin.diagnostics`	列出所有有buffers的诊断列表, 或者通过指定bufnr列出特定buffer的诊断. 
* `builtin.lsp_references`	列出光标处的所有引用. 
* `builtin.lsp_definitions`	跳转到光标元素的定义(如果只有一个), 如果可能有多个选择,则列出所有的可能定义.
* `builtin.lsp_incoming_calls`	列出光标处函数的所有调用者.
* `builtin.lsp_outgoing_calls`	列出光标处函数里调用的所有函数.
* `builtin.lsp_implementations`	Goto the implementation of the word under the cursor if there's only one, otherwise show all options in Telescope
* `builtin.lsp_type_definitions`	Goto the definition of the type of the word under the cursor, if there's only one, otherwise show all options in Telescope
* `builtin.lsp_dynamic_workspace_symbols`	Dynamically Lists LSP for all workspace symbols
* `builtin.lsp_document_symbols`	Lists LSP document symbols in the current buffer
* `builtin.lsp_workspace_symbols`	Lists LSP document symbols in the current workspace

### vim pickers

插件开发和vim配置可以参考以下pickers

* `builtin.commmands` 查找所有可用的vim commands, 以及他们执行的代码, 回车执行.
* `builtin.autocommmands` 查找所有生效的auto commands, 以及他们声明的代码
* `builtin.vim_options` 列出所有生效的vim options, 以及他们的生效范围,值.
* `builtin.registers` 列出所有vim寄存器里的内容, 回车插入光标位置.
* `builtin.keymaps` 查找keymap
* `builtin.filetypes` 查找filetypes
* `builtin.highlights` 列出所有代码高亮设置.


project.nvim
=========

`:Telescope projects` 列出打开过的工程列表.

在列表中, 可以使用以下快捷键, 可以对project目录下执行:

| Insert mode | Action                  |
| ----        | ----                    |
| <c-r>       | 最近编辑过的project文件 |
| <c-w>       | 切换cwd到project根目录  |
| <c-d>       | 删除project             |
| <c-f>       | 文件搜索                |
| <c-s>       | live_grep(内容搜索)     |


Session
========

提供了两个autocmd命令: 

| Event           | Description                                                                      |
|-----------------|----------------------------------------------------------------------------------|
| SessionSavePre | Executed before a session is saved                                                |
| SessionLoadPre | Executed before a session is loaded. 可以在session加载前做一些清理工作. |
| SessionSavePost | Executed after a session is saved                                                |
| SessionLoadPost | Executed after a session is loaded. 可以在session加载后做一些工作空间的准备工作. |

示例:

```lua
local config_group = vim.api.nvim_create_augroup('MyConfigGroup', {}) -- A global group for all your config autocommands

vim.api.nvim_create_autocmd({ 'SessionLoadPost' }, {
group = config_group,
callback = function()
require('nvim-tree').toggle(false, true)
end,
})
```

Easymothion
===========

默认是`<leader><leader>`触发, 可重新映射:

示例:
```
nmap s  <Plug>(easymotion-s2)
"用easymotion的sn 替代vim默认的搜索功能: 使用 / 触发 sn 搜索,  输入搜索词, 如果当前屏幕没有找到, 可以使用Tab, S-Tab 翻页, 回车, 选择跳转目标. 使用 n,N 在多个目标之间移动
map  / <Plug>(easymotion-sn)
omap / <Plug>(easymotion-tn)
map  n <Plug>(easymotion-next)
map  N <Plug>(easymotion-prev)
```

vim 对象
========

vim.inspect
----------

转换对象为可阅读的形式

vim.o
------

访问 vim options

vim.g
------

vim 全局变量

vim.env
--------

访问环境变量

vim.fn
------

访问 vim 内置函数

vim.api
-------

范围 neovim 内置函数

```
:h api
```

## nvim_create_autocmd

```lua
vim.api.nvim_create_autocmd({ 'SessionLoadPost' }, {
callback = function()
	vim.o.title = true
	local f = vim.loop.cwd()
	if f ~= nil then
		local root_files = {
			f .. '/.git',
			f .. '/.svn',
			f .. '/.hg',
			f .. '/.idea',
			f .. '/go.mod',
			f .. '/package.json',
		}

		local dirs = vim.fn.split(f, "/")
		if dirs ~= nil then
			local project_name = '[ ' .. dirs[#dirs] .. ' ]'
			for _, v in pairs(root_files) do
				if vim.fn.getftype(v) == 'dir' then
					vim.o.titlestring = project_name
				end
				if vim.fn.getftype(v) == 'file' then
					vim.o.titlestring = project_name
				end
			end
		end
	end
end,
})
```

## nvim_set_keymap

```
vim.api.nvim_set_keymap("n", "<C-a>", require("dial.map").inc_normal(), { noremap = true })

```

## nvim_create_user_command

```
:call nvim_create_user_command('SayHello', 'echo "Hello world!"', {})
:SayHello
```

DAP
=====

## 插件

### mfussenegger/nvim-dap

基础插件,需要为语言配置单独

### nvim-telescope/telescope-dap.nvim

commands:

```vim
:Telescope dap commands
:Telescope dap configurations
:Telescope dap list_breakpoints
:Telescope dap variables
:Telescope dap frames
```

apis:

```lua
require'telescope'.extensions.dap.commands{}
require'telescope'.extensions.dap.configurations{}
require'telescope'.extensions.dap.list_breakpoints{}
require'telescope'.extensions.dap.variables{}
require'telescope'.extensions.dap.frames{}
```


## 使用

`h dap.txt`

* launch debug adapter
* `lua require'dap'.continue()`
* toggle breakpoints
* `toggle_breakpoint({condition}, {hit_condition}, {log_message})`
* 普通断点: `require('dap').toggle_breakpoint()` 
* 条件断点: `require'dap'.set_breakpoint(vim.fn.input('Breakpoint condition: ')`
* Logpoint断点: `require'dap'.set_breakpoint(nil, nil, vim.fn.input('Log point message: '))`
* list all breakpoints
* `require('dap').list_breakpoints()`
* clear all breakpoints
* `require('dap').clear_breakpoints()`
* step over, step into, step out
* `require'dap'.step_over()`
* `require'dap'.step_into()`
* `require'dap'.step_out()`
* step back, reverse continue
* `require'dap'.step_back()`
* `require'dap'.reverse_continue()`
* pause
* `require'dap'.pause()`
* Goto
* `require'dap'.run_to_cursor()`
* stop
* `require'dap'.terminate()`
* repl
* `require'dap'.repl.open()`


### logpoint

```
set_breakpoint({condition}, {hit_condition}, {log_message})
toggle_breakpoint({condition}, {hit_condition}, {log_message})
```

这两个api在设置断点时，如果没有任何参数，就是无条件断点。

* 如果设置了 condition，则为条件断点
* 如果设置了 hit_condition，是一个数字字符串，即最多在断点处暂停几次。
* 如果设置了 log_message，则为log断点,只打日志，不阻塞执行. log_message 支持变量

### 远程调试

1. 在远程服务器上安装dlv :`go install github.com/go-delve/delve/cmd/dlv@latest`
2. 拿到服务器上要调试的go服务进程id
3. 在远程服务器上启动dlv : `dlv attach 进程id --headless --listen=:2345 --api-version=2 --accept-multiclient`
* 或者执行 `dlv exec ./main  --headless -l=:2345 --api-version=2  --accept-multiclient`, 由dlv来启动进程并自动attach.
	dlv只在有client连接以后才会真正启动进程.
4. 执行 `:GoDebug`  选择远程调试的adapter

### rcarriga/nvim-dap-ui

# go.nvim

## GoTest

1. GoTest 在success的时候，只输出成功。不会自动打开quickfix窗口显示log. 在fail的时候自动打开quickfix窗口显示log.
2. go test 会缓存结果, 禁用缓存可以使用 `go test -count=1` 或清除缓存 `go clean -testcache`

## Debug

| command        | Description                                        |
|----------------|----------------------------------------------------|
| GoDebug -h     | 显示 Debug 帮助                                    |
| GoDebug -b     | 添加/取消断点                                      |
| BreakCondition | 添加/取消条件断点                                  |
| GoDebug        | 开启调试会话, 备注:1                               |
| GoDebug -t     | 为test代码开启调试会话, 备注:2                     |
| GoDebug -p     | 为Package test代码开启调试会话                     |
| GoDebug -n     | 为最近的 go test file 开启调试会话                 |
| GoDebug -R     | 重新开始调试会话                                   |
| GoDbgKeys      | 在浮动窗口显示debug键绑定                          |
| GoDebug -s     | 结束调试会话并恢复撤销 debug keymap                |
| GoDbgStop      | Same as GoDebug -s                                 |
| GoDebug -a     | 启动 dlv, 并选择一个本地进程, attach到进程上debug |
| GoDbgContinue  | Continue debug session                             |
| BreakCondition | 添加条件断点                                       |

备注:

1. 如该不使用任何参数, 则弹出select窗口选择 launch.json 里的配置和dap插件的 `dap.configurations.go` 配置中的一项启动调试. 
* 如launch.json不存在, 则根据当前文件，启动main()或package的调试.
2. with -t option, if current file is not test file, will switch to test file and run test for current function

### 远程调试

先安装 vscode-go

```sh
cd ~
git clone https://github.com/golang/vscode-go
cd vscode-go
npm install
npm run compile
```

修改 nvim-dap 配置:

```lua
dap.adapters.remoteDlv = {
	type = "executable";
	command = "node";
	args = { os.getenv("HOME") .. "/vscode-go/dist/debugAdapter.js" };
}

dap.configurations.go = {
	-- 远程
	{
		type = "remoteDlv";
		request = "attach";
		mode = "remote";
		name = "Remote Attached Debugger";
		port = 2345; // dlv server 端口
		host = '127.0.0.1'; // dlv server host
		cwd = vim.loop.cwd();
	},
}
```

注意:

1. 如该没有任何 dlv client连接，则 dlv server会暂停进程的运行.
2. dlv在某代码处stop时，是对进程的stop, 此时整个进程被暂停.
3. dlv服务 以  --accept-multiclient 启动时，debug session退出不会导致dlv server退出. 
4. dlv服务 不以  --accept-multiclient 启动时，debug session 退出会导致dlv server退出. 

### keymap

调试会话启动后会注册启用以下键绑定(注意，会覆盖vim默认的键绑定), 需要使用`:GoDbgStop`或`:GoDebug -s` 恢复键绑定:

```
b -> toggle_breakpoint
r -> run （launch debug adapter）
S -> stop
c -> continue
C -> run_to_cursor
n -> step_over
s -> step_into
o -> step_out
P -> pause
u -> up
D -> down
K -> float_element
```

## GoGet GoMod

请使用 `:GoGet`, `:GoModInit`, `:GoModTidy`, `:GoModVendor` 管理依赖，他们会重启gopls, 否则需要自己使用 `:LspResart` 重启Lsp服务.

## Build and test

## Project

支持使用 launch.json, .gonvim 创建项目配置

https://code.visualstudio.com/docs/editor/debugging#_launch-configurations



## 效率工具

| command                  | Description                                        |
|--------------------------|----------------------------------------------------|
| :GoJson2Struct           | 从剪贴板的json生成go struct.                       |
| :GoAlt/GoAltS/GoAltV     | 源码和测试文件之间切换                             |
| :{range}GoAddTag [flags] | 例如: `:GoAddTag json -add-options json=omitempty` |
| :GoImpl                  | 为选择的struct添加实现某个接口的方法               |
| :GoCmt                   | 添加包、接口、结构、方法注释                       |
| :GoRename                |                                                    |
| :GoAddTest               |                                                    |
| :GoIfErr                 |                                                    |
| :GoChannel               |                                                    |
| :GoGenerate              |                                                    |
| :GoCallStack             |                                                    |
| :GoFillSwitch            | 自动创建类型switch的所有case条件                   |
| :GoMockGen               | 生成mock                                           |
| :GoPkgOutline            | 显示当前包的outline                                |



luasnip
======

使用`<tab>/<s-tab>` 在snippets变量之间跳转. 快捷键配置在自动完成插件配置里。

go
-----

用 ~可以呼出snip列表

go重复率比较高的代码片段都是错误处理和测试代码

go.nvim 提供了以下snip

### 常用片段:

* `main`
* `fn`
* `mk`
* `spn`  fmt.Sprintf("")
* `tysw` type swtich
* `fsel` channel for select case
* `for` for loop

### 错误处理有关的代码片段:

* `ife`  : if err!=nil { }
* `ifc` : call a function and check err
* `ifce` : if err:=func();err!= nil 
* `dfr` : defer recover  处理
* `erw` : errors.Wrap(err,"failed to")
* `erwf`: errors.Wrap(err,"failed %v",arg)


### 测试有关的snipets

* `test` test函数definition
* `tcs`  test case code
* `gocmp`
* `noerr`
* `bench` benchmark

# nvim-cmp

`:h cmp-develop`

相关api: `cmp.SourceCompletionApiParams`, `lsp.CompletionResponse`, `lsp.CompletionItem`



# Git 操作

Gitsign和Telescope 可以满足基本的 文件diff, 分支管理

## Gitsigns

主要功能:

1. 添加git状态标记: 支持gutter颜色，gutter符号，编辑区底色高亮
2. 将变更全部发送到 loclist 或 quickfix(如果安装了trouble.nvim则发送到trouble), 方便在提交前check代码
3. 集成到null-ls, 支持在代码变更区域触发 code action
4. 方便的 blame : 可使用虚拟text显示光标所在行的 committer, commit msg, time
* `:Gitsigns toggle_current_line_blame`
4. hunks
* preview_hunk: 单独在floating window预览hunk diff.
* 提供了 Hunk text object
* next_hunk/prev_hunk: 导航
* stage_hunk : stage光标处的hunk/或选择的范围
* undo_stage_hunk : undo上一次stage_hunk的内容.
* stage_buffer: stage 所有hunks 
* reset_hunk: 撤销Hunk的变更
* reset_buffer: reset 所有修改，内容恢复到修改前的状态
* reset_buffer_index: 所有已经stage的Hunks都变更到unsage状态，内容并没有改变
5. Diff against index or any commit
6. Open diffview with any revision/commit
* 在any base和index之间diff 当前buffer
* `:Gitsigns diffthis({base})` 默认是与上一个commit diff
* `:Gitsigns change_base({base},{global})`
* `:Gitsigns reset_base({global})`
* diff with the index: `:Gitsigns diffthis`
* diff with the last commit: `:Gitsigns diffthis ~1`

## Telescope git_command

### git_bcommits

列出当前buffer的commit历史

* `<cr>` checkout 
* `<c-v>` 打开垂直diff窗口, 对HEAD与所选择的commit进行diff.

### git_commits

默认列出当前仓库的commit历史

可以通过参数，列出指定path的commit历史: 配合NvimTree 实现 

选择commit 回车可以 checkout

### git_branches

分支管理

* `<cr>` checkout
* `<c-t>` track
* `<c-a>` add 
* `<c-y>` merge
* `<c-r>` rebase
* `<c-d>` delete

### git_stash

列出 stash列表，回车可以apply到工作区

## diffview

中文乱码处理, 添加3条配置(/etc/gitconfig, ~/.gitconfig):

```
git config --global core.quotepath false
git config --global i18n.commitEncoding utf-8
git config --global i18n.logOutputEncoding utf-8
```

| 一般快捷键  | 功能                                 |
|-------------|--------------------------------------|
| `<leader>b` | toggle file pannel或者history pannel |
| `gf`        | goto file: 打开文件                  |
| `L`         | 查看 选择的commit 的完整信息         |


| file_panel 快捷键 | 功能                   |
|-------------------|------------------------|
| `-`               | toggle stage file      |
| `S`               | Stage all files        |
| `U`               | UnStage all files      |
| `X`               | Reset select file        |
| `R`               | Update all files state |

| history_panel 快捷键 | 功能                   |
|----------------------|------------------------|
| `y`                  | copy hash              |

主要提供了以下命令, 查看当前分支的commit diff:

### DiffviewOpen

1. 查看commit之间的diff(可以使用HEAD,commit hash,tagname,branch name)
	* 命令自带自动完成功能
2. 查看工作区与index之间的diff, 在file_panel里可以进行 
    * stage(`S`)/unstage(`U`)操作,
	* 使用 `-` 可以对单个文件进行 stage/unstage
3. 如果在 merge 或者 rebase 操作时使用，则选择冲突文件时, 会使用3-way diff 方便你
处理冲突. 左侧是Ours(冲突之前的本地分支),右侧是Theirs(被合并进来的分支),中间是待解决冲突的本地index文件
	* 使用 `]x`,`[x` 在冲突之间跳转.
	* `<leader>co`: Choose the OURS version of the conflict.
	* `<leader>ct`: Choose the THEIRS version of the conflict.
	* `<leader>cb`: Choose the BASE version of the conflict.
	* `<leader>ca`: Choose all versions of the conflict (effectively just deletes the markers, leaving all the content).
	* `dx`: Choose none of the versions of the conflict (delete the conflict region).

```
:DiffviewOpen [git rev] [options] [ -- {paths...}]
```

示例:

```
:DiffviewOpen
:DiffviewOpen HEAD~2
:DiffviewOpen HEAD~4..HEAD~2
:DiffviewOpen d4a7b0d
:DiffviewOpen d4a7b0d..519b30e
:DiffviewOpen origin/main...HEAD
```

### DiffviewFileHistory

1. 查看文件目录的hisotry commit
2. 查看文件选择的范围的history commit
3. 查看单个文件的历史时，可以通过 `--follow` 关联起重命名之前的history
4. `-n{n}`可以指定 history 的commit最大数量.
5. `--author={pattern}` 可以指定commit的提交者
6. `--grep={pattern}` 可以通过commit message 过滤提交
7. 键映射支持Lua function, 比较灵活，可以实现: 两个commit之间的DiffviewOpen, 从commit创建分支,创建tag

```
:[range]DiffviewFileHistory [paths] [options]
```

示例:

```
:DiffviewFileHistory
:DiffviewFileHistory %
:DiffviewFileHistory path/to/some/file.txt
:DiffviewFileHistory path/to/some/directory
:DiffviewFileHistory include/this and/this :!but/not/this
:DiffviewFileHistory --range=origin..HEAD
:DiffviewFileHistory --range=feat/example-branch
:'<,'>DiffviewFileHistory
```

### 其他命令

```
:DiffviewClose: Close the current diffview. You can also use :tabclose.
:DiffviewToggleFiles: Toggle the files panel.
:DiffviewFocusFiles: Bring focus to the files panel.
:DiffviewRefresh: Update stats and entries in the file list of the current Diffview.
```

# text object

| text object | 说明                                                                   | plugin                         |
| ----        | ----                                                                   | ----                           |
| ai/ii,aI/iI | 根据当前行的缩进量，从相邻的行开始选择，直到遇到缩进更少的或者空行为止 | kana/vim-textobj-indent        |
| a,/i,       | 函数参数                                                               | sgur/vim-textobj-parameter     |
| au/iu       | url                                                                    | mattn/vim-textobj-url          |
| al/il       | 一行文本,不含末尾的空白字符                                            | kana/vim-textobj-line          |
| ac/ic       | 注释                                                                   | glts/vim-textobj-comment       |
| ao/io       | 相同缩进距离的多行行首的空白列缩进                                     | glts/vim-textobj-indblock      |
| as/is       | 句子,即中间没有空白行的连续的多行文本                                  | reedes/vim-textobj-sentence    |

## nvim-treesitter-textobjects

支持以下text objects, 默认会根据语言自动注册.

```
(aB)@block		      go dart rust python c cpp csharp java js lua php ts
(aS)@class		      go dart rust python c cpp csharp java js     php ts
(aC)@conditional      go dart rust python c cpp csharp java js lua php ts 
(aF)@function         go dart rust python c cpp csharp java js lua php ts
(aL)@loop             go dart rust python c cpp csharp java js lua php ts 
(am)@comment.outer    go dart rust python c cpp csharp java    lua php     
(ast)@statement.outer go dart rust python c cpp csharp                     
(aca)@call	          go dart rust python c cpp csharp java js lua     ts
@parameter            go dart rust python c cpp csharp java js lua php ts 
```

# tommcdo/vim-exchange

- 在第一个objext上 执行 cx{text object}, 然后在到另一个objext上执行cx{text objcet} 即可进行交换. 如果第二个motion和第一个motion相同,可以使用 .

# text-case 单次大小写风格切换

快捷键: `ga.`

# Dial

ctrl-a,ctrl-x增强

配置了go的时间format,  `int,int32,in64`,  `uint,uint32,uin64`, `[]byte(/string(`, `and/or`, `&&/||`, `GET/POST`, `Error/Warn/Info/Debug`, `true/false`,
`success/error`, `desc/asc`, `min/max`, `disable/enable`,  `disabled/enabled`

# link-visitor

* `VisitLinkInBuffer`  Open links in the buffer
* `VisitLinkUnderCursor`  Open link under the cursor
* `VisitLinkNearCursor`  Open link near the cursor

# 多重编辑

有两种选择内容的方式: cursor模式和extend模式

## cursor模式多重选择操作

cursor模式用来在不同的行里面选择相同的文本。

* 光标移动到一个单词上，按下ctrl-n 会选中这个单词，然后n会增加选中下一处出现的该单词, 按下 N 会增加选中上一处出现的该单词.
* 选择多个目标后，可以使用 shift+方向键，同时在多个目标上移动光标，调整所有目标的选择范围.
* 也可以先在visual模式选择初始文本，然后用ctrl-n加选下一处相同文本.

cursor模式选择完成后，执行任意编辑操作(删除，insert)后会自动进入extend模式

## extend模式操作

用来按列选择字符，可以选择很多列，不限于一列。

具体操作: nomarl模式下，使用 `<c-up>`,`<c-down>` 在列上下移动光标进行选择，当按下 `<c-up>`,`<c-down>`后，光标落到的 **字符** 被选择

extend模式编辑完成后esc会仍然返回extend模式, 再次esc退出多重编辑模式.

extend模式下可以通过hljk改变选择的列和行，如果单纯移动光标不改变选择，需要使用方向键.

注:与mac系统快捷键冲突,需要禁用系统的快捷键.

## tab切换选择模式

多重选择完成后，可以按tab切换到extend模式

## 选择完成后的操作

* 选择完成后，可以按下x, 一次删除选择的所有内容；
* 按下 i, I, a, A ，在 **每一处选择的文本** 上进入对应的insert模式，开始多重编辑.

| Key | Action                                              |
|-----|-----------------------------------------------------|
| n   | find next (same as C-n)                             |
| N   | find previous                                       |
| ]   | goto next                                           |
| [   | goto previous                                       |
| q   | skip and go to next                                 |
| Q   | remove region                                       |
| C-f | fast forward (go to first region in next page)      |
| C-b | fast backward (go to first region in previous page) |

# markdown

## vim-markdown

该插件和treesitter markdown 冲突

| Cmd            | 说明         |
|----------------|--------------|
| `Toc`         | 创建文档目录 |
| `TableFormat` | 格式化表格   |

### 折叠键映射

* zr: reduces fold level throughout the buffer
* zR: opens all folds
* zm: increases fold level throughout the buffer
* zM: folds everything all the way
* za: open a fold your cursor is on
* zA: open a fold your cursor is on recursively
* zc: close a fold your cursor is on
* zC: close a fold your cursor is on recursively


The rules for the cursor position are the same as the gx command.

### 在header间移动

* `]]`: go to next header.
* `[[`: go to previous header. 
* `][`: 移动到下一个同级header
* `[]`: 移动到上一个同级header
* `]h`: go to Current header.
* `]u`: go to parent header (Up).

## dhruvasagar/vim-table-mode

快捷键 : 

| 快捷键        | 说明          | 配置变量                                             |
|---------------|---------------|------------------------------------------------------|
| `<Leader>tm`  | 切换tablemode | -                                                    |
| `<Leader>tdd` | 删除行        | `g:table_mode_delete_row_map='<Leader>tdd'`          |
| `<Leader>tdc` | 删除列        | `g:table_mode_delete_column_map='<Leader>tdc'`       |
| `<Leader>tic` | 后面插入列    | `g:table_mode_insert_column_after_map='<Leader>tic'` |
| `<Leader>tiC` | 前面插入列    | `g:table_mode_insert_column_after_map='<Leader>tic'` |



### 编辑录入表格

启用 table mode后， 使用markdown语法，写完第一行的表头以后，会车(不能离开insert mode), 在第二行，连续输入两个 `|` 就会自动插入表头分割行.
然后继续编辑录入表格单元格部分时，可以自动调整表格的列宽.

### 文本转表格

`<Leader>tt` 可以将csv这样固定分隔的序列数据转为表格。

`<Leader>T` 可以将选择的文本转为表格，会要求你输入分隔符。

### 单元格光标移动

在单元格之间快速移动: `[|`, `]|`, `{|` , `}|` to move left | right | up | down cells

### 单元格 text object

单元格 Text Object: `a|`, `i|`

### 排序

`<Leader>ts` : 依据光标所在列进行字符串比较模式的升序排序

```
:TableSort[!] [i][u][r][n][x][o]
```

TableSort 的参数和sort命令的参数一样，感叹号代表降序:

默认为字符串比较，区分大小写

* `i` : 字符串比较，忽略大小写
* `l` : 如果有中文，一般要加这个(use current collation locale)
* `n` : 十进制 number
* `f` : float 
* `x` : 十六进制
* `o` : 8进制
* `b` : 2进制
* `u` : 去重

### 表格对齐

支持表格内文本对齐方向语法

```
| 左对齐 | 右对齐 |
|--------|-------:|
| left   |  right |
```


### Table Formulas

可以代替excel做一些简单的整列数值或者单元格表格数据计算

表达式: `$cell_target = formula`, 

cell_target  有两种格式: 

1. `$n`, 整列选择. 列编号，可以是负数，代表从后往前。
2. `$n,m`, 单元格选择. (n行号，列m号)列编号，可以是负数，代表从后往前。

formula 可以是一个类似cell_target一样的简单表达式的运算，还可以在formula里使用所有的vim原生函数。 并且额外提供了Sum, Average 两个函数。这些函数接受一个range作为参数。函数参数格式如下:
1. `r1:r2`: 从当前列上选择一段范围. 代表当前列上第一行到第二行之间的单元格
2. `r1,c1:r2,c2`: 代表第一行第一列到第二行第二列
3. 注意函数参数的分隔符后面要有空格，否则会被当做一个整体.

一些表达式示例:

```
$2 = $1 * $1  -- 第二列的值等于第一列乘以第一列
$2 = pow($1, 5) NOTE: Remember to put space between the $1, and 5 here otherwise it will be treated like a table cell.
$2 = $1 / $1,3 
$1,2 = $1,1 * $1,1
$5,1 = Sum(1:-1)
$5,1 = float2nr(Sum(1:-1))
$5,3 = Sum(1,2:5,2)
$5,3 = Sum(1,2:5,2)/$5,1
$5,3 = Average(1,2:5,2)/$5,1
```

#### 获得单元格的位置表达式

表格很大时，要知道一个单元格的位置，可以在单元格上使用 `<Leader>t?`, 在命令行会输出位置.

#### TableEvalFormulaLine

可以使用在表格下面添加 formula line(` tmf: 表达式1;表达式2`), 然后执行.

执行 table formula : `<Leader>tfe`

#### TableAddFormula

添加 table formula : 在一个单元格上使用 `<Leader>tfa` , 或者 `:TableAddFormula`, 执行结果会自动创建formula line

### 示例

原表格:

```
| 2    | 2    | 5    |
| 2    | 11   | 8    |
| 3    | 2    | 0    |
<!-- tmf: $2=$1*$3 -->
```

执行后:

```
| 2 | 10 | 5 |
| 2 | 16 | 8 |
| 3 | 0  | 0 |
<!-- tmf: $2=$1*$3 -->
```

执行完以后，删掉 formula line

# Copilot AI 编程

https://www.youtube.com/watch?v=SXtMnn1v7d8

https://github.com/github/copilot.vim

https://docs.github.com/en/copilot

快捷键:

| 键  | 说明                             |
|-----|----------------------------------|
| a-j | 接受建议                         |
| a-] | 下一个建议                       |
| a-[ | 上一个建议                       |
| c-] | 忽略当前建议                     |
| a-\ | 请求一个建议，即使自动建议被关闭 |

Copilot 子命令

| 子命令  | 说明                                                                                  |
|---------|---------------------------------------------------------------------------------------|
| setup   | 认证并启用copilot                                                                     |
| auth    | 认证                                                                                  |
| enable  | 启用copilot                                                                           |
| disable | 关闭copilot                                                                           |
| signout | 退出认证                                                                              |
| status  | 查看当前状态是否正常                                                                  |
| panel   | 在当前需要建议的地方(例如 AI建议注释下一行，代码行尾)执行，可以提供最多10个完成建议, 使用 `[[`,`]]` 在建议之间移动. 使用 `<cr>` 接受建议 |

## golang copilot 经验

Copilot 的工作原理是基于对github上大量代码库的阅读，相当于一个具有一定智能的高级搜索引擎。根据你当前的代码，从其海量代码阅读经验中快速找到可能是你接下来想要的代码片段。

因此，它的智能程度相当有限，并没有逻辑推理能力，给出的代码建议仍然需要你仔细确认采用，不可盲从。

因此，官方也仅仅将copilot定义为你的“结伴编程帮手”, 是一个帮你打杂的角色，为你节省一些琐碎代码的编写时间，以及搜索引擎搜索时间。

对于业务逻辑性的代码，它为你节省的时间可能不多。但对于算法类的代码，它可以快速提供非常准确的解决方案（只要leetcode上有）。

### 快速定义struct

一个大写英文单词作为注释，可以为你建议struct定义.

```go
// Animal
type Animal struct {
    Name string
    Age  int
}
```

你甚至可以先想好结构的fields,methods,再让copilot提供建议:

```go
// People : a struct that represents a person with fields: Id, Name, and Age
type People struct {
    Id int
    Name string
    Age int
}
```

也可以在注释里写上方法，copilot也可以提供生成建议

```go
// Article: a struct that represents an article with fields: Id, Title, and Content,
// with methods: GetTitle and GetContent
type Article struct {
    Id int
    Title string
    Content string
}

func (a Article) GetTitle() string {
    return a.Title
}

func (a Article) GetContent() string {
    return a.Content
}
```

甚至可以在注释里写上需要实现的interface. 不过要在输入完`func`关键字以后才会触发接口方法建议

```go
// Article: a struct that represents an article,
// and implement interface: Stringer, Marshaler, Unmarshaler
type Article struct {
    Id int
    Title string
    Content string
}

func (a Article) String() string {
    return a.Title
}

func (a Article) MarshalJSON() ([]byte, error) {
    return []byte(a.Title), nil
}

func (a *Article) UnmarshalJSON(data []byte) error {
    a.Title = string(data)
    return nil
}
```

当你的struct已经定义了一些方法时，copilot也可以给你提供一些新方法的建议。比如你为某个字段定义了setter方法，那么copilot就可以自动为你建议它的getter方法，以及其他字段的setter,getter方法。


我们可以接受方法推荐，然后在推荐的代码基础上，用`dif`快速删除代码块，修改完善形参和返回值定义后，让copilot重新建议代码块.

#### struct tag

用 copilot 可以很方便地补充struct tag, 能很好地提示 json,gorm,参数验证相关的tag

### 快速创建函数

注意: 函数逻辑建议是基于copilot学习过的逻辑代码进行建议，因此前提是你需要的建议在github代码库中有类似的功能和实现,且这些实现的注释能被copilot认为和你写的注释有非常的相似性.


两种方法:

1. 不用注释，直接通过合理的函数命名就可以提供函数建议，但是不要基于接受建议，把函数的参数和返回值定义完以后提供的建议才是可用性更好的建议。
2. 通过注释(建议英文)说明函数功能和逻辑，由copilot提供建议.
3. 如果是算法实现，通过标准的中英文算法描述就可以推荐出来.

生成的代码建议，可能里面会用到一些没有定义过的函数，那么这些未定义的函数需要继续让copilot进行建议. 直到所有相关函数都被建议补全。

如果是算法实现，copilot也可以直接给你拉出leetcode的链接:

```
// 函数: 求两组整数的中位数
// 参数：nums1,nums2 两组整数
// 返回值：中位数
// document: https://leetcode-cn.com/problems/median-of-two-sorted-arrays/
```

上门的链接就是在输入 document以后自动建议出来的

### import package

在import代码块内通过注释，可以要求copilot接下来提供package引用建议.

```go
import(
    // import a postgres driver
)
```

如果知道package name，可以更准确地提供建议:

```go
import(
    // import redigo, gorm, and mysql driver
    "github.com/gomodule/redigo/redis"
    "gorm.io/gorm"
    "gorm.io/driver/mysql"
)
```

### 业务逻辑代码加速

1. 根据代码编写进度，自动推断出接下来你想写的代码，属于一个高级版的代码智能提示。
2. 在写业务逻辑时，可以通过注释让copilot替你写一些重复的简单的逻辑性代码片段.
    * 能够成功推荐的前提是，代码库中存在一些代码，这些代码的注释与你写的注释相同或相似,否则也是无法提供建议的.
    * 这就可能导致推荐的代码，需要你在修改完善才能使用. 比如推荐的代码不完全匹配你的代码上下文，或者推荐的代码过于陈旧。

## nvimdev/lspsaga.nvim

lsp 实用工具

* `Lspsaga lsp_finder` 查找所有用到该标识符的地方
    * enter : 在列表中切换目标
    * o : 在新窗口打开目标
    * p : 光标进入预览窗口
* `Lspsaga incoming_calls` 列出所有调用光标所在函数的外部函数
    * enter : 在列表中切换目标
    * o : 在新窗口打开目标
    * p : 光标进入预览窗口
    * u : 折叠展开列表
* `Lspsaga outgoing_calls` 列出光标所在函数里调用的所有函数
* `Lspsaga peek_definition` 浮动窗口显示定义 , 
    * `<c-t>` 返回
    * `<c-c>v` 垂直窗口打开
* `Lspsaga peek_type_definition` 浮动窗口显示类型定义

